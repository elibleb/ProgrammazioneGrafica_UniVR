#define _USE_MATH_DEFINES
#include <cmath>


#include "QuatCamera.h"


#include "defines.h"
#include <iostream>

//Assi del sistema di coordinate World
const glm::vec3 WORLDX = glm::vec3(1,0,0);
const glm::vec3 WORLDY = glm::vec3(0,1,0);
const glm::vec3 WORLDZ = glm::vec3(0,0,1);


/////////////////////////////////////////////////////////////////////////////////////////////
// Costruttore
/////////////////////////////////////////////////////////////////////////////////////////////
	QuatCamera::QuatCamera() 
	{
		reset();
	}

/////////////////////////////////////////////////////////////////////////////////////////////
// Ottieni la posizione
/////////////////////////////////////////////////////////////////////////////////////////////
	const glm::vec3& QuatCamera::position() const
	{
		return _position;
	}

/////////////////////////////////////////////////////////////////////////////////////////////
// Imposta la posizione
/////////////////////////////////////////////////////////////////////////////////////////////
	void QuatCamera::setPosition(const glm::vec3& position)
	{
		_position = position;
	}


/////////////////////////////////////////////////////////////////////////////////////////////
// Ottieni il campo di vista FOV
/////////////////////////////////////////////////////////////////////////////////////////////
	float QuatCamera::fieldOfView() const
	{
		return _fieldOfView;
	}

/////////////////////////////////////////////////////////////////////////////////////////////
// Imposta il campo di vista
/////////////////////////////////////////////////////////////////////////////////////////////
	void QuatCamera::setFieldOfView(float fieldOfView)
	{
		assert(fieldOfView>0.0f && fieldOfView <180.0f);
		_fieldOfView = fieldOfView;
	}

/////////////////////////////////////////////////////////////////////////////////////////////
// Ottieni aspectRatio
/////////////////////////////////////////////////////////////////////////////////////////////
	float QuatCamera::aspectRatio() const
	{
		return _aspectRatio;
	}

/////////////////////////////////////////////////////////////////////////////////////////////
// Imposta aspectRatio
/////////////////////////////////////////////////////////////////////////////////////////////
	void QuatCamera::setAspectRatio(float aspectRatio)
	{
		assert(aspectRatio > 0.0f);
		_aspectRatio = aspectRatio;
	}


/////////////////////////////////////////////////////////////////////////////////////////////
// Ottieni il nearPlane
/////////////////////////////////////////////////////////////////////////////////////////////
	float QuatCamera::nearPlane() const
	{
		return _nearPlane;
	}

/////////////////////////////////////////////////////////////////////////////////////////////
// Imposta il far Plane
/////////////////////////////////////////////////////////////////////////////////////////////
	float QuatCamera::farPlane() const
	{
		return _farPlane;
	}

	
/////////////////////////////////////////////////////////////////////////////////////////////
// Imposta nearPlane e farPlane
/////////////////////////////////////////////////////////////////////////////////////////////
	void QuatCamera::setNearAndFarPlanes(float nearPlane, float farPlane)
	{
		assert(nearPlane > 0.0f);
		assert(farPlane > nearPlane);
		_nearPlane = nearPlane;
		_farPlane = farPlane;
	}

///////////////////////////////////////////////////////////////////////////////////////////
// Genera un quaternione a partire da un asse e un angolo di rotazione in radianti
// Questo serve per costruire il quaternione di rotazione
////////////////////////////////////////////////////////////////////////////////////////////

	glm::quat fromAxisAngle(glm::vec3 axis, float angle)
	{
		glm::quat rotation;

		rotation.w = cos(angle/2);
		rotation.x = sin(angle/2) * axis.x;
		rotation.y = sin(angle/2) * axis.y;
		rotation.z = sin(angle/2) * axis.z;
	
		return rotation;

	}

/////////////////////////////////////////////////////////////////////////////////////////////
//Ruota la fotocamera
// Orienta in base a pitch e yaw richiesti
/////////////////////////////////////////////////////////////////////////////////////////////
	void QuatCamera::rotate(const float yaw, const float pitch)
	{

		glm::quat rotatePitch = fromAxisAngle(WORLDX, pitch);
		glm::quat normalisedPitchQuat = glm::normalize(rotatePitch);

		normalisedPitchQuat = normalisedPitchQuat * _orientation;

		_orientation = normalisedPitchQuat;
		

		glm::quat rotateYaw = fromAxisAngle(WORLDY, yaw);
		glm::quat normalisedYawQuat = glm::normalize(rotateYaw);

		normalisedYawQuat = _orientation * normalisedYawQuat;

		_orientation = normalisedYawQuat;

		updateView();




	}

	
/////////////////////////////////////////////////////////////////////////////////////////////
// Panoramica della fotocamera
/////////////////////////////////////////////////////////////////////////////////////////////
	void QuatCamera::pan(const float x, const float y)
	{
		
		_position += _xaxis * x;
		_position += _yaxis * -y;
		
		//chiama update()
		updateView();
	}

/////////////////////////////////////////////////////////////////////////////////////////////
//Zoom della fotocamera
/////////////////////////////////////////////////////////////////////////////////////////////
	void QuatCamera::zoom(const float z)
	{

		_position += _zaxis * z;
			
		//chiama updateView()
		updateView();

	}

/////////////////////////////////////////////////////////////////////////////////////////////
// Aggiorna la vista della fotocamera
/////////////////////////////////////////////////////////////////////////////////////////////
	void QuatCamera::updateView()
	{
		//Costruisce la matrice di vista a partire dal quaternione di orientamento e dal vettore di posizione

		//Prima si ottiene la matrice dal quaternione 'orientamento'
		//Questo si occupa della parte di rotazione e scala della matrice di vista
		_view = glm::mat4_cast(_orientation); // Rotazione e scala

		//Estrae gli assi della fotocamera da questa matrice
		_xaxis = glm::vec3(_view[0][0],_view[0][1],_view[0][2]);
		_yaxis = glm::vec3(_view[1][0],_view[1][1],_view[1][2]);
		_zaxis = glm::vec3(_view[2][0],_view[2][1],_view[2][2]);

		//E si utilizza questo e la posizione attuale della fotocamera per impostare la parte di traslazione della matrice di vista
		_view[3][0] = -glm::dot(_xaxis,_position); //Translation x
		_view[3][1] = -glm::dot(_yaxis,_position); //Translation y
		_view[3][2] = -glm::dot(_zaxis,_position); //Translation z
	
	}

/////////////////////////////////////////////////////////////////////////////////////////////
// Ripristina l'orientamento
/////////////////////////////////////////////////////////////////////////////////////////////
	void QuatCamera::roll(const float z)
	{

		glm::quat rotateZ = fromAxisAngle(WORLDZ, z);
		glm::quat normalisedRollQuat = glm::normalize(rotateZ);

		normalisedRollQuat = _orientation * normalisedRollQuat;

		_orientation = normalisedRollQuat;

		updateView();
	}


/////////////////////////////////////////////////////////////////////////////////////////////
// Ripristina la fotocamera
/////////////////////////////////////////////////////////////////////////////////////////////
	void QuatCamera::reset(void)
	{
		//Inizializza gli assi della fotocamera
		_xaxis = WORLDX;
		_yaxis = WORLDY;
		_zaxis = WORLDZ;

		//Inizializza la posizione della fotocamera 
		_position= glm::vec3(0.0f,10.0f,25.0f);

		//Inizializza l'orientamento
		_orientation = glm::quat(1.0,0.06,0.0,0.0);

		//Inizializza i parametri di prospettiva della fotocamera
		_fieldOfView = glm::radians(90.0f);
		_nearPlane = 0.01f;
		_farPlane = 200.0f;
		_aspectRatio = 4.0f/3.0f;

		_projection = glm::perspective(_fieldOfView,_aspectRatio,_nearPlane,_farPlane);

		updateView();
	}

/////////////////////////////////////////////////////////////////////////////////////////////
// Restituisci la matrice di vista della fotocamera
/////////////////////////////////////////////////////////////////////////////////////////////
	glm::mat4 QuatCamera::view() 
	{
	
		this->updateView();
		return _view;
	}

/////////////////////////////////////////////////////////////////////////////////////////////
// Restituisci la matrice di proiezione della fotocamera
/////////////////////////////////////////////////////////////////////////////////////////////
	glm::mat4 QuatCamera::projection() 
	{

		return _projection;
		
	}

	